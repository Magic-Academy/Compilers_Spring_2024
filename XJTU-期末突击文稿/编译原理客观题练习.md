
1 编译是对()。

A. 机器语言的执行

B. 汇编语言的翻译

**C. 高级语言的翻译**

D. 高级语言程序的解释执行

2 用高级语言编写的程序经编译后产生的程序叫( ).

A. 源程序

**B. 目标程序**

C. 连接程序

D. 解释程序

3 ( )不是编译程序的组成部分。

A. 词法分析程序

B. 代码生成程序

**C. 设备管理程序**

D. 语法分析程序

4 源程序是句子的集合，( )可以较好地反映句子的结构。

A. 线性表

**B. 树**

C. 完全图

D. 堆栈

5 编译程序是一种( )。

A. 汇编程序

**B. 翻译程序**

>翻译程序有两种：
>1) 编译程序。它将高级语言一次全部翻译成目标程序，每次执行程序时，只需要执行目标程序，因此只要源程序不变，就无需重新编译。
>2) 解释程序。它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一跳源程序语句并执行，直至所有源程序语句全部都被翻译完

C. 解释程序

D. 目标程序

6 按逻辑上划分，编译程序第三步工作是( )。

**A. 语义分析**

B. 词法分析

C. 语法分析

D. 代码生成

7 编译程序中 *语法分析器* 接收以( )为单位的输入。

**A. 单词**

B. 表达式

C. 产生式

D. 句子

8 编译过程中，*语法分析器* 的任务就是( )。

A. 分析单词是怎样构成的

**B. 分析单词串是如何构成语句和声明的**

C. 分析语句和声明是如何构成程序的

D. 分析程序的结构

9 语法分析时所依据的是( )

**A. 语法规则**

B. 词法规则

C. 语义规则

D. 等价变换规则

10 通常一个编译程序中，不仅包含词法分析，语法分析，语义分析，中间代码生成，代码优化，目标代码生成等六个部分，还应包括( )。

**A. 表格处理和出错处理**

B. 解释器

C. 模拟执行器

D. 符号执行器


11 编译程序绝大多数时间花在( )上。

A. 词法分析

B. 目标代码生成

C. 出错处理

**D. 表格管理**


## 程序设计语言及其文法

4 文法G产生的( )的全体是该文法描述的语言。

A. 句型

B. 终结符集

C. 非终结符集

**D. 句子**

5 若文法G定义的语言是无限集，则文法必然是( )。

**A. 递归的**

B. 上下文无关的

C. 二义性的

D. 无二义性的

6 乔姆斯基(Chomsky)把文法分为四种类型，即0型、1型、2型、3型。其中3型文法是( )。

A. 非限制文法

**B. 正则文法**

C. 上下文有关文法

D. 上下文无关文法

7 一个上下文无关文法G包括四个组成部分，它们是一组非终结符号，一组终结符号，一个开始符

号，以及一组( )。

A. 句子

**B. 产生式**

C. 单词

D. 句型

8 若一个文法是递归的，则它所产生的语言的句子( )。

**A. 是无穷多个**

B. 是有穷多个

C. 是可枚举的

D. 个数是常量

9 给定文法A→bA|cc，则符号串①cc ②bcbc ③bcbcc ④bccbcc ⑤bbbcc中，是该文法句子的是( )。

A. ①

B. ③④⑤

C. ②④

**D. ①⑤**

10 文法E→E+E|EE|i的句子ii+i*i有( )棵不同的语法树。

A. 1

B. 3

**C. 5**

D. 7

13 由文法的开始符号*出发经过若干步（包括0步）推导产生的文法符号*序列称为( )。

A. 语言

**B. 句型**

C. 句子

D. 句柄

14 下列符号串不可以由符号集S＝{a,b}上的正闭包运算产生的是( )。  
  
A. ε

B. a

C. aa

D. ab


## 词法分析

1 词法分析器的输出结果是( )。

A. 单词自身值

B. 单词在符号表中的位置

C. 单词的种别编码

**D. 单词的种别编码和自身值**

2 词法分析器不能( )。

A. 识别出数值常量

B. 过滤源程序中的注释

C. 扫描源程序并识别记号

**D. 发现括号不匹配**

3 ( )这样一些语言，它们能被确定的有穷自动机识别，但不能用正则表达式表示。

A. 存在

**B. 不存在**

C. 无法判定是否存在

D. 以上答案都不对

4 两个有穷自动机等价是指它们的( )。

A. 状态数相等

B. 有向弧数相等

**C. 所识别的语言相等**

D. 状态数和有向弧数相等

5 词法分析器用于识别( )。

A. 句子

B. 产生式

**C. 单词**

D. 句型

6 正则表达式 R1和R2 等价是指( )。

A. R1和R2 都是定义在一个字母表上的正则表达式

B. R1和R2 使用的运算符相同

**C. R1和R2 代表同一正则集**

D. R1和R2 代表不同正则集

10 有限状态自动机能识别( )。

A. 上下文无关语言

B. 上下文有关语言

**C. 正规语言**

D. 0 型文法定义的语言

11 ( )不是DFA的成分。

A. 有穷字母表

**B. 多个初始状态的集合**

C. 多个终态的集合

D. 转换函数

13 有穷自动机M1和M2等价是指( )。

A.M1和M2的状态数相等

B. M1和M2的有向边条数相等

**C. M1和M2所识别的语言集相等**

D. M1和M2状态数和有向边条数相等

15 称有限自动机 A1和A2 等价是指( )。

A. A1和A2 都是定义在一个字母表上的有限自动机

B. A1和A2 状态数和有向边数相等

C. A1和A2 状态数或有向边数相等

**D. A1和A2 所能识别的字符串集合相等**

16 两个DFA等价是指( )。

A. 这两个DFA的状态数相同

B. 这两个DFA的状态数和有向弧条数都相等

C. 这两个DFA的有向弧条数相等

**D. 这两个DFA接受的语言相同**

18 词法分析器的**加工对象**是（）。

A. 中间代码

B. 单词

**C. 源程序**

D. 元程序

19 如果一个正规式所代表的集合是*无穷的*，则它必含有的运算是( )。

A. 接运算“·”

B. 或运算“|”

**C. 闭包运算“\* ”**

>无穷 => 程序递归 => 闭包

D. 括号“（”和“）”

20 同正规式ab 等价的文法是( )。

A. G1：S→aS|bS|ε

B. G2：S→aSb|ε

**C. G3：S→ aS|Sb|ε**

D. G4:S→ abS|ε

21 一个正规式只能对应一个确定的有限状态自动机。

A. 对

**B. 错**

22 一个正规语言可能对应多个正规文法。

**A. 对**

B. 错


## 语法分析

1 如果文法G是无二义的，则它的任何句子α( )。

**A. 最左推导和最右推导对应的语法树必定相同**

B. 最左推导和最右推导对应的语法树可能不同

C. 最左推导和最右推导必定相同

D. 可能存在两个不同的最左推导，但它们对应的语法树相同
 

2 采用自上而下分析，不必( )。

A. 消除回溯

B. 消除左递归

**C. 消除右递归**

D. 提取公共左因子
 

3 识别上下文无关语言的自动机是( )。

**A. 下推自动机**

B. NFA

C. DFA

D. 图灵机


4 ( )文法不是LL(1)的。

A. 递归

B. 右递归

C. 2型

**D. 含有公共左因子的**


5 已知文法G是无二义的，则对G的任意句型α( )。

**A. 最左推导和最右推导对应的语法树必定相同**

B. 最左推导和最右推导对应的语法树可能相同

C. 最左推导和最右推导必定相同

D. 可能存在两个不同的最左推导，但他们对应的语法树相同
 

6 在自上而下的语法分析中，应从( )开始分析。

A. 句型

B. 句子

**C. 文法开始符号**

D. 句柄

 
7 一个文法G，若( )，则称它是LL（1）文法。

A. G中不含左递归

B. G无二义性

**C. G的LL（1）分析表中不含多重定义的条目**

D. G中产生式不含左公因子
 

8 *语法分析器的输入*是（）。

**A. Token序列**

B. 源程序

C. 目标程序

D. 符号表


9 在递归子程序方法中，若文法存在左递归，则会使分析过程产生( )。

A. 回溯

B. 非法调用

C. 有限次调用

**D. 无限循环**


10 LL（1）分析法中“1”的含义是在输入串中查看一个输入符号，其目的是（ ）。

A. 确定最左推导

B. 确定句柄

**C. 确定使用哪一个产生式进行展开**

D. 确定是否推导


语法分析_2

1 在语法分析处理中，FIRST集合、FOLLOW集合均是( )。

A. 非终结符集

**B. 终结符集**

C. 字母表

D. 状态集
 

2 在*编译过程中，如果遇到错误*应该( )。

A. 把错误理解成局部的错误

B. 对错误在局部范围内进行纠正，继续向下分析

**C. 当发现错误时，跳过错误所在的语法单位继续分析下去**

D. 当发现错误时立即停止编译，待用户改正错误后再继续编译
 

3 已知文法G\[S]:

S→eT|RT T→DR|ε R→dR|ε D→a|bd

求FIRST(S)=（）。

A. {e }

B. {e，d，a，b}

C. {e，d }

**D. {e，d，a，b，ε}**

 
4 已知文法G[S]:

S→eT|RT T→DR|ε R→dR|ε D→a|bd

求FOLLOW(D)=（）。

A. {d,e}

B. {d,ε}

**C. {d,$}**

D. {a,d}


5 FIRST集中可以含有ε。

**A. 对**

B. 错

 
6 FOLLOW集中可以含有ε。

A. 对

**B. 错**
 

7 SELECT集中可以含有ε。

A. 对

**B. 错**


语法分析_3

1 若a为终结符，则A→α · aβ为( )项目。

A. 归约

**B. 移进**

C. 接受

D. 待约


**归约项目（Reduction Item）**

归约项目是指在LR分析中，一个项目已经匹配到某个产生式的右部，并准备应用这个产生式进行归约。形式上，它的特征是**项目点在产生式右部的最右侧**。

例如，对于产生式 A→αA \rightarrow \alphaA→α，归约项目表示为：

A→α⋅A \rightarrow \alpha \cdotA→α⋅

在这个项目中，点号（·）表示输入已经匹配了产生式 A→αA \rightarrow \alphaA→α 的右部，并且可以进行归约。

**移进项目（Shift Item）**

移进项目表示分析器当前已匹配到某个产生式的部分右部，且下一步需要将下一个输入符号移进来以继续匹配。形式上，它的特征是**项目点位于产生式右部的非终结符或终结符之前**。

例如，对于产生式 A→αβA \rightarrow \alpha \betaA→αβ，移进项目表示为：

A→α⋅βA \rightarrow \alpha \cdot \betaA→α⋅β

在这个项目中，点号（·）表示输入已经匹配了 α\alphaα，并且需要匹配 β\betaβ 以完成产生式的匹配。

**接受项目（Accept Item）**

接受项目是指在LR分析中，整个**输入已经完全匹配文法的开始符号的产生式**。这是**一个特定的归约项目，表示分析成功地解析了整个输入**。

对于文法的开始符号 SSS 和增加的产生式 S′→SS' \rightarrow SS′→S，接受项目表示为：

S′→S⋅S' \rightarrow S \cdotS′→S⋅

这里，点号（·）在产生式的最右侧，表示整个输入已经成功匹配并可接受。

**待约项目（Handle Item）**

待约项目是指在输入串中已经识别出某个子串，这个子串可以用一个产生式的右部进行替换（归约）。待约项目通常用来表示当前分析器正在考虑是否进行归约。例如，对于产生式 A→αA \rightarrow \alphaA→α，待约项目表示为：

A→α⋅A \rightarrow \alpha \cdotA→α⋅

这个术语有时与归约项目相似，因为它们都表示即将进行归约的状态

2 一个句型中的( )称为该句型的句柄。

**A. 最左直接短语**

B. 最右直接短语

C. 终结符

D. 非终结符
 

3 在**自底向上的语法分析**方法中，分析的关键是( )。

**A. 寻找句柄**

B. 寻找句型

C. 消除递归

D. 选择候选式
 

4 在自顶向下的语法分析方法中，分析的关键是( )。

A. 寻找句柄

B. 寻找句型

C. 消除递归

**D. 选择候选式**


5 若B为非终结符，则 A→a · Bb 为( )。

A. 移进项目

B. 归约项目

C. 接受项目

==D. 待约项目==

 
6 在规范归约中，用( )来刻画**可归约串**。

A. 直接短语

**B. 句柄**

C. 最左素短语

D. 素短语
 
 
7 若B为非终结符，则A→α·Bβ为( )项目。

A. 归约

B. 移进

C. 接受

**D. 待约**
 

8 下列动作中，不是**自下而上**分析动作的是( )。

A. 移进

**B. 展开**

C. 接受

D. 报错
 
 
9 下列动作中，不是**自上而下**分析动作的是( )。

A. 匹配

B. 展开

**C. 移进**

D. 报错


11 设有文法G\[T]:

T→T\*F|F

F→F↑P|P

P→(T)|a

该文法句型TP↑(TF)的句柄是下列符号串 。

A. （T*F）

B. T*F

**C. P**

D. P↑(T*F)
 

12 **LR分析表中的转移表（goto）**是以（）作为列标题的。

A. 终结符

**B. 非终结符**

C. 终结符或非终结符

D. 表示状态的整型数
 

13 LR分析表中的**动作表（action）**是以（ ）作为列标题的。

A. 终结符

B. 非终结符

C. 终结符或非终结符

**D. 终结符和结束符$**


14 下列项目中为可归约项目的是（）。

A. E′→· E

**B. L→·**

C. L→-· L

D. F→L*· F


15 LR分析器的核心部分是一张分析表，该表由( )组成。

A. ACTION表

B. GOTO表

C. 预测分析表

**D. ACTION表和GOTO表**


语法分析_4

1 一个LR(1)文法合并同心集后*若不是LALR(1)文法*( )

A. 则可能存在移进/归约冲突

**B. 则可能存在归约/归约冲突**

C. 则可能存在移进/归约冲突和归约/归约冲突

D. 以上说法都不对

 
2 若状态k含有项目“A→α· ”，且仅当输入符号a∈FOLLOW(A)时，才用规则“A →α”归约的

语法分析方法是( )。

A. LALR分析法

B. R(0)分析法

C. LR(1)分析法

**D. SLR(1)分析法**

 
3 LR(1)文法都是( )。

A. 无二义性且无左递归

B. 可能有二义性但无左递归

**C. 无二义性但可能是左递归**

>LR(1)天然没有二义性，但是它可能有左递归（直接/间接）

D. 可以既有二义性又有左递归


4 **同心集合并**可能会产生新的( )冲突。

A. 二义

B. 移进/移进

C. 移进/归约

**D. 归约/归约**
 
 
5 就文法的描述能力来说，有( )。
A. SLR(1) ⊂ LR(0)

B. LR(1) ⊂ LR(0)

**C. SLR(1) ⊂ LR(1)**
D. 无二义文法 ⊂ LR(1)


6 在LR(0)的Action表中，如果某行中存在标记为“rj”的栏，则( )。

**A. 该行必定填满“rj”** 

B. 该行未必填满“rj”

C. 其他行可能也有“rj”

D. goto表中也可能有“rj”


7 若状态k含有项目“A→α·”，对任意非终结符a，都用规则“A →α”归约的语法分析方法是( )。

A. LALR分析法

**B. LR(0)分析法**

C. LR(1)分析法

D. SLR(1)分析法


8 在SLR( 1)的Action表中，如果某行中存在标记为“rj”的栏，则( )。

A. 该行必定填满“rj”

**B. 该行未必填满“rj”**
C. 其他行可能也有“rj”
D. goto表中也可能有“rj”


9 若状态k含有项目“A→α·”，且仅当输入符号a∈FOLLOW( A)时，才用规则“A →α”归约的语

法分析方法是( )。

A. LALR分析法

B. LR(0)分析法

C. LR(1)分析法

**D. SLR(1)分析法**
 

10 编译程序的**语法分析器必须输出**的信息是( )。

A. 语法规则信息

**B. 语法错误信息**

C. 语法分析过程

D. 语句序列


## 语法制导翻译

1 文法G\[S]及其语法制导翻译定义如下：

产生式 语义动作

S’ → S print( S.num)

S → ( L) S.num = L.num +1

S → a S.num = 0

L →L( 1), S L.num = L( 1).num + S.num

L →S L.num = S.num

若输入为( a,( a))，且采用自底向上的分析方法，则输出为( )。

A. 0

B. 1

**C. 2**

D. 4
 

2 有文法G及其语法制导翻译如下所示( 语义规则中的*和+分别是常规意义下的算术运算符)：

E→E( 1) ∧ T {E.val = E( 1).val * T.val}

E→T {E.val = T.val}

T→T( 1)# n {T.val = T( 1).val + n.val }

T→ n {T.val = n.val}

则分析句子3 ∧ 3 # 4其值为（）。

A. 10

**B. 21**

C. 14

D. 24

>方法：按照语法规则把运行的语法树画出来，就可以了

3 有一语法指导定义如下：

S→bAb print “1”

A→( B print “2”

A→a print “3”

B→aA) print “4”

若输入序列为b( a( a( aa)))b，且采用自底向上的分析方法，则输出序列为( )。

A. 32224441

B. 34242421

**C. 12424243**

D. 34442212

>注意这里B/C容易混淆，自底向上分析，输出是自顶向下

4 有一语法指导定义如下，其中+表示符号连接运算：

S→B print B.vers

B→a B.vers=a

B→b B.vers=b

B→Ba B.vers=a+B.vers

B→Bb B.vers=b+B.vers

若输入序列为abab，且采用自底向上的分析方法，则输出序列为( )。

A. aabb

B. abab

C. bbaa

**D. baba**


5 使用( )可以定义一个**程序的意义**。

**A. 语义规则**

B. 词法规则

C. 产生规则

D. 词法规则

 
6 以下说法正确的是( )。

**A. 语义规则中的属性有两种：综合属性与继承属性**

B. 终结符只有继承属性，它由词法分析器提供

C. 非终结符可以有综合属性，但不能有继承属性

D. 属性值在分析过程中可以进行计算，但不能传递
 

7终结符具有( )属性。

A.抽象

B.传递

**C.综合**

D.继承


语法制导翻译_2

1 关于将L-SDD转换为SDT的规则，以下选项中，正确的是( )。

A. 将计算某个非终结符号A的继承属性的动作放在产生式的最后

B. 将计算一个产生式左部符号的继承属性的动作放置在产生式的最后

**C. 将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上**

D. 将每个语义动作都放在产生式的最后

 
2 以下说法不正确的是( )。

A. 如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LL语法分析过程中实现

>S-SDD（综合属性定义）中的属性是在产生式的右侧推导过程中计算的，这与自底向上的LR分析相匹配，而不是自顶向下的LL分析

B. 如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析过程中实现

C. 如果一个L-SDD的基本文法可以使用LL分析技术，那么它的SDT可以在LL语法分析过程中实现

>L-SDD（继承属性定义）中的属性是在产生式的左侧推导过程中计算的，这与自顶向下的LL分析相匹配

D. 如果一个L-SDD的基本文法可以使用LL分析技术，那么它的SDT可以在LR语法分析过程中实现

>L-SDD也可以在LR分析过程中实现，因为LR分析（自底向上）可以通过在移进和归约过程中进行属性计算，这并不影响继承属性的传递和计算

3 以下说法不正确的是( )。

A. 使用语法制导翻译方案的编译程序能同时进行语法分析和语义分析

B. 语法制导翻译方案( SDT )是在产生式右部中嵌入了程序片段( 称为语义动作)的CFG

**C. SDD可以看作是SDT的具体实施方案**

>- SDD（语法制导定义）和SDT（语法制导翻译），C将二者颠倒了
>- SDD是定义了语义规则和属性的计算方法，而SDT是实现这些规则的方法

D. 将一个S-SDD转换为SDT的方法是：将每个语义动作都放在产生式的最后

 
4 在非递归的预测分析过程中进行翻译，以下说法**不正确**的是( )。

A. 要想在非递归的预测分析过程中进行翻译，需要扩展语法分析栈

B. 非终结符A的继承属性和综合属性的计算时机不同

C. 将非终结符A的继承属性和综合属性存放在不同的记录中

**D. 综合属性在A出现之前就可以计算**


5 在非递归的预测分析过程中进行翻译，以下说法**不正确**的是( )。

A. 要想在非递归的预测分析过程中进行翻译，需要扩展语法分析栈

B. 综合记录用于存放非终结符综合属性值

C. 动作记录，用来存放指向将被执行的语义动作代码的指针

**D. 综合属性存放在A本身的记录中**
 

6 在非递归的预测分析过程中进行翻译，以下说法不正确的是( )。

A. 分析栈中的每一个记录都对应着一段执行代码

B. 综合记录出栈时，要将综合属性值复制给后面特定的语义动作

C. 变量展开时( 即变量本身的记录出栈时)，如果其含有继承属性，则要将继承属性值复制给后面特定的语义动作

**D. 继承属性在A的儿子们都分析完毕之后才能计算**


语法制导翻译_3

1 在*递归的预测分析*过程中进行翻译，以下说法**不正确**的是( )。

A. 可以将一个递归的预测分析器扩展为一个翻译器

B. 在语法分析器中，每个非终结符A对应一个过程，在做语义分析时，要将过程扩展成一个函数

C. 以继承属性作为函数的参数，以综合属性作为函数的返回值

**D. 以综合属性作为函数的参数，以继承属性作为函数的返回值**


2 在*递归的预测分析*过程中进行翻译，以下说法不正确的是( )。

A. 在语法分析器中，每个非终结符A对应一个过程，在做语义分析时，要将过程扩展成一个函数

>**正确**。在递归下降的预测分析器中，每个非终结符确实对应一个过程。为了实现语义分析，这个过程通常需要扩展为一个函数，以便处理属性传递和计算

B. 对出现在A产生式右部中的每个文法符号的每个属性都设置一个局部变量

>在进行属性计算时，为了便于管理和访问出现在产生式右部的每个文法符号的属性，通常会为每个属性设置局部变量。这使得在语法分析过程中可以方便地操作这些属性

C. 如果非终结符含有继承属性，需要将函数调用的返回值赋给相应的局部变量

>- **不正确**。
>- 如果非终结符含有继承属性，这些继承属性通常是在函数调用的参数中传递的，而不是通过函数调用的返回值赋给局部变量。
>- 继承属性在调用时就应该被传递，而不是在调用之后再通过返回值进行传递。
>- 作为返回值进行传递的是综合属性

D. 对于产生式右部的每个动作，将其代码复制到语法分析器，并把对属性的引用改为对相应变量的引用

>在递归下降分析器中，对于产生式右部的每个动作，通常会将其代码复制到相应的位置，并将对属性的引用改为对相应局部变量的引用。这是为了确保属性计算和操作在正确的语法分析上下文中进行。


3 以下说法不正确的是( )。

**A. 语法制导翻译方案只限自底向上的分析方法**

B. 给定一个以LL文法为基础的L-SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD

C. 对于这个内嵌的语义动作，向文法中引入一个标记非终结符M来替换它

D. 每个标记非终结符M对应着一个空产生式M→ ε，该产生式对应着一段语义子程序，它的任务就是完成M所替换的那个语义动作要完成的工作

 
4 给定一个以LL文法为基础的L-属性定义，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD。

**A. 对**

B. 错


5 在各个非终结符之前放置语义动作来计算它的继承属性， 并在产生式后端放置语义动作计算综合属性。

**A. 对**

B. 错


6 在各个非终结符之前放置语义动作来计算它的综合属性， 并在产生式后端放置语义动作计算继承属性。

A. 对

**B. 错**
 

7 对每个内嵌的语义动作，向文法中引入一个标记非终结符来替换它。每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式M→ε。

A. 对

B. 错


## 中间代码生成

中间代码生成_1

1 **中间代码生成**时所依据的是( )。

A. 语法规则

B. 词法规则

**C. 语义规则**

D. 等价变换规则
 

2 在编译程序中与中间代码生成无关的是( )。

A. 便于目标代码的优化

B. 便于存储空间的组织

C. 便于编译程序的移植

**D. 便于目标代码的移植**


3 以下说法不正确的是( )。

A. 对于声明语句，语义分析的主要任务就是收集标识符的类型等属性信息，为每一个名字分配一个相对地址

B. 从变量类型可以知道该变量在运行时刻需要的内存数量。在编译时刻，可以使用这些数量为每一个名字分配一个相对地址

C. 名字的类型和相对地址信息保存在相应的符号表条目中

**D. 对声明的处理要构造符号表，但不产生中间代码**


4 以下说法不正确的是( )。

A. 类型自身也有结构，用类型表达式来表示这种结构

**B. 基本类型不是类型表达式**

C. 类型名也是类型表达式

D. 将类型构造符作用于类型表达式可以构成新的类型表达式


5 数组元素的地址计算与数组的存储方式有关。

**A. 对**

B. 错

1. **一维数组**：
	- 一维数组在内存中是连续存储的。假设数组的起始地址为 basebasebase，每个元素的大小为 sizesizesize，则第 iii 个元素的地址可以通过以下公式计算： Address(A[i])=base+i×size
2. **二维数组**：
    - **行优先（Row-major order）**：这是大多数编程语言（如C/C++）的默认存储方式。假设二维数组 AAA 有 nnn 列，每个元素的大小为 sizesizesize，则元素 A[i][j]A[i][j]A[i][j] 的地址计算公式为： Address(A[i][j])=base+(i×n+j)×size
    - **列优先（Column-major order）**：一些语言（如Fortran）使用这种存储方式。假设二维数组 AAA 有 mmm 行，每个元素的大小为 sizesizesize，则元素 A[i][j]A[i][j]A[i][j] 的地址计算公式为： Address(A[i][j])=base+(j×m+i)×size
3. **多维数组**：
    - 多维数组的存储方式是上述方式的推广，行优先或列优先都会有相应的地址计算公式，具体公式会根据数组的维数和具体存储方式有所不同。


6 在程序中标识符的出现仅为使用性的。

A. 对

**B. 错**


7 在编译阶段只对可执行语句进行翻译。

A. 对

**B. 错**
 

8 在程序中标识符的出现仅为定义性的。

A. 对

**B. 错**

- **使用性（Usage）**：
    - 标识符被用来引用其所表示的对象，例如变量的读取、函数的调用等。
    - 例子：在 `x = y + 2` 中，`y` 是以使用性的形式出现。
- **定义性（Definition）**：
    - 标识符被用来创建或定义一个新的对象，如变量声明、函数定义等。
    - 例子：在 `int x;` 中，`x` 是以定义性的形式出现。
- **声明性（Declaration）**：
    - 标识符被声明，但不一定是定义。例如，函数的前向声明或变量的外部声明。
    - 例子：在 `extern int x;` 中，`x` 是以声明性的形式出现。这意味着`x`在其他地方定义了，但这里我们只是声明它的存在。
- **参数性（Parameter）**：
    - 标识符作为函数参数出现。
    - 例子：在 `void func(int x)` 中，`x` 是以参数性的形式出现。
- **标签性（Label）**：
    - 标识符被用作跳转标签，例如在使用`goto`语句时。
    - 例子：在 `label: x = 1; goto label;` 中，`label` 是以标签性的形式出现。


第12讲 中间代码生成_2

1 有文法G及其语法制导翻译如下所示( 语义规则中的*和+分别是常规意义下的算术运算符)：

E→E(1) ∧ T {E.val = E(1).val * T.val}

E→T {E.val = T.val}

T→T(1)# n {T.val = T(1).val + n.val }

T→ n {T.val = n.val}

则分析句子1 ∧ 2 ∧ 3 # 4其值为( )。

A. 10

B. 34

**C. 14**

D. 54


2 用( )可以把a:=b+c翻译成四元式序列。

A. 语法规则

B. 词法规则

**C. 语义规则**

D. 等价变换规则


3 有文法G及其语法制导翻译如下所示( 语义规则中的\*和+分别是常规意义下的算术运算符)：

E→E(1) ∧ T {E.val = E(1).val * T.val}

E→T {E.val = T.val}

T→T(1)# n {T.val = T(1).val + n.val }

T→ n {T.val = n.val}

则分析句子2 ∧ 3 # 4其值为( )。

A. 10

B. 21

**C. 14**

D. 24
 

4 以下说法不正确的是( )。

A. ==赋值语句翻译的主要任务是生成对表达式求值的三地址码==

B. 在增量翻译方法中，gen( )函数不仅要构造出一个新的三地址指令，还要将它添加到至今为止已生成的指令序列之后

C. 如果一个赋值语句中涉及到数组元素，那么将该语句翻译成三地址码时要解决的主要问题是确定数组元素的存放地址，也就是数组元素的寻址

**D. 数组元素的地址计算与数组的存储方式无关**


5 数组元素的地址由两部分构成，一部分是基地址，另一部分是偏移量。

**A. 对**

B. 错
 

6 基地址通过查符号表即可获得。

**A. 对**

B. 错

 
7 数组元素的偏移地址的计算只取决于数组的下标。

A. 对

**B. 错**


8 设计数组引用的SDT的关键问题是：如何将地址计算公式和数组引用的文法关联起来。

**A. 对**

B. 错
 

中间代码生成_3

1 关于布尔表达式的叙述，**不正确**的是( )。

A. 布尔常量是布尔表达式

**B. 布尔常量不是布尔表达式**

C. 关系表达式是布尔表达式

D. 将括号和逻辑运算符作用于布尔表达式得到一个新的布尔表达式

>bool常量 是 bool表达式
 

2 以下说法不正确的是( )。

A. 为布尔表达式和控制流语句生成目标代码时，关键问题之一是确定跳转指令的目标标号

**B. 在生成跳转指令时，就可以确定目标标号**

C. 在生成跳转指令时，目标标号还不能确定

D. 可以将标号的地址作为*继承属性*传递到生成相关跳转指令的地方，但是这样的做法需要再进行一趟处理，将标号和具体地址绑定起来


5 在分支和循环中会用到条件式，而用作条件式的通常是布尔表达式。

**A. 对**

B. 错


6 在控制流语句的翻译中，布尔表达式B被翻译成由跳转指令构成的跳转代码。

**A. 对**

B. 错


7 逻辑运算符&&、|| 和 ! 会出现在代码中。

A. 对

**B. 错**


8在跳转代码中，逻辑运算符&&、|| 和 ! 被翻译成跳转指令。

**A. 对**

B. 错


2 在下面的语句中，( )**不需要回填技术**。

**A. 赋值语句**

B. goto语句

C. 条件语句

D. 循环语句


3 四元式之间的联系是通过( )实现的。

A. 指示器

**B. 临时变量**

C. 符号表

D. 程序变量
 

4 四元式表示法的优点为 ( )。

**A. 不便于优化处理，但便于表的更动**

B. 不便于优化处理，但节省存储空间

C. 便于优化处理，也便于表的更动

D. 便于表的更动，也节省存储空间
 

5 在**回填技术**中，生成一个跳转指令时，暂时不指定该跳转指令的目标标号。

**A. 对**

B. 错


6 在回填技术中，==同一个列表list中的跳转指令具有相同的目标标号==。

**A. 对**

B. 错
 

7 在回填技术中，同一个列表list中的跳转指令可能具有不同的目标标号。

A. 对

**B. 错**
 

8 在回填技术中，等到能够确定正确的目标标号时，才去填充指令的目标标号。

**A. 对**

B. 错


## 运行存储分配

1 在*目标代码生成阶段*，符号表用于()。

A. 目标代码生成

B. 语义检查

C. 语法检查

**D. 地址分配**


2 PASCAL语言中过程声明的局部变量地址分配在( )。

A. 调用者的数据区中

**B. 被调用者的数据区中**

C. 主程序的数据区中

D. 公共数据区中

>当一个过程（或函数）__被调用__ 时，程序会为该过程分配一个活动记录（也称为栈帧）。这个活动记录包含了过程执行期间所需的所有信息，包括局部变量、参数、返回地址和一些状态信息。
>- **被调用者的数据区**：当一个过程被调用时，它会在栈上分配一个新的活动记录，这个记录包含了该过程的局部变量。因此，局部变量是分配在被调用者的数据区中的。
>- 这种机制保证了每次过程调用都有独立的一组局部变量，不会与其他过程调用的局部变量混淆。


3 编译方法中，**动态存储分配**的含义是()。

A. 在编译阶段为源程序中的量进行分配

B. 在编译阶段为源程序中的量进行分配，运行时可动态调整

**C. 在==运行阶段==为源程序中的量进行分配（在运行阶段对源程序中的数组、变量、参数等进行分配）**

D. 都不正确
 

4 *运行阶段的存储组织与管理*的目的是( )。

A. 提高编译程序的运行速度

**B. 为运行阶段的存储分配做准备及提高目标程序的运行速度**

C. 优化运行空间的管理

D. 节省内存空间
 

5 以下说法正确的是( )。

A. 对于数据空间的存贮分配，FORTRAN采用动态贮存分配策略

>传统的FORTRAN仅含有静态存储策略

B. 对于数据空间的存贮分配，C语言仅采用栈式贮存分配策略

C. 动态存储分配是指在编译阶段对源程序中的量进行分配，以使目标代码在运行时加快运行速度

**D. 如果两个临时变量的作用域不相交，则可以将它们分配在同一单元中**
 

6 以下说法正确的是( )。

**A. 编译程序除解决源程序中用户定义的量在运行时刻的存储组织与分配问题之外，还应完成为临时变量和参与运算的寄存器组织好存储空间的任务**

B. 由于C语言的函数允许递归调用，因此对C语言中的所有变量的单元分配一律采用动态分配方式

C. 动态数组的存储空间在编译时即可完全确定

D. “运算符与运算对象类型不符”属于语法错误
 

7 以下说法正确的是( )。

A. 符号表由词法分析程序建立，由语法分析程序使用

B. 符号表的内容在词法分析阶段填入并在以后各个阶段得到使用

**C. 对一般的程序设计语言而言，其编译程序的符号表应包含哪些内容及何时填入这些信息不能一概而论**

D. “运算符与运算对象类型不符”属于语法错误


>符号表：
>- **创建阶段**：符号表在 *词法分析* 和 *语法分析* 阶段创建和填充。
>- **使用阶段**：符号表在 *语法分析、语义分析、中间代码生成、代码优化* 和目标代码生成阶段使用


